I wanted to try using AI to create additional exercises for the C++ modules of the 42 curriculum and explore how it could support learning. Using ChatGPT, I crafted an initial prompt which I then refined through several iterations to generate exercises with the Claude model.
The final prompt requested a progressive series of C++ exercises that introduce key language features (such as classes, inheritance, and templates) while aligning with the pedagogical style and constraints of the module. The exercises were designed to offer original problems and contexts, each accompanied by a clear explanation of the concepts being taught, with particular attention to highlighting differences and advantages of C++ over C.
To ensure the exercises closely resembled those of the module 00 in my training, I selectively incorporated key concepts, formats, and constraints from the subject as reference points.
From the generated exercises, I retained only those that brought new and valuable learning opportunities.

Here is the prompt i built with Chat-GPT and sent to Claude.

I have a solid foundation in C but am completely new to C++. Using this example document as a guide, please generate a new, alternative series of C++ exercises designed to help me grasp the language effectively.
* The exercises should progressively introduce key C++ features (like classes, inheritance, templates,  etc.) while respecting the constraints and topics in the document.
* They should not simply repeat the examples or exercises in the attached reference but offer fresh problems and contexts.
* Each exercise should be clearly stated, with a brief explanation of the concepts it aims to teach.
* Keep in mind my C background: focus on highlighting the differences and advantages of C++ over C.
* Include a mix of practical coding tasks and conceptual questions to deepen understanding.

Claude generated : 

## Exercise 01: Simple Calculator Class
**Turn-in directory:** `ex01/`  
**Files to turn in:** `Makefile, Calculator.hpp, Calculator.cpp, main.cpp`  
**Forbidden functions:** None

**Concepts introduced:** Classes, member functions, encapsulation, constructors

Create a `Calculator` class that maintains a running total and performs basic arithmetic operations:

```cpp
// Example usage:
Calculator calc;
calc.add(5);
calc.multiply(3);
calc.subtract(2);
std::cout << "Result: " << calc.getResult() << std::endl; // Result: 13
calc.clear();
calc.divide(10, 2);
std::cout << "Result: " << calc.getResult() << std::endl; // Result: 5
```

**Requirements:**
- The class should have private member for storing the current result
- Implement: `add()`, `subtract()`, `multiply()`, `divide()`, `clear()`, `getResult()`
- Handle division by zero appropriately
- Constructor should initialize result to 0

**Interactive mode:** Your main should allow users to enter commands like:
```
> add 5
> mul 3
> sub 2
> show
Result: 13
> quit
```

**Key learning:** This introduces you to the fundamental concept of encapsulation - data (the result) is private and can only be modified through controlled public methods.

## Exercise 04: Simple String Class
**Turn-in directory:** `ex04/`  
**Files to turn in:** `Makefile, MyString.hpp, MyString.cpp, main.cpp`  
**Forbidden functions:** None

**Concepts introduced:** Dynamic memory management, copy constructor, assignment operator, destructor (Orthodox Canonical Form basics)

Create a simplified string class that manages its own memory:

**MyString class requirements:**
- Private: `char* data`, `size_t length`
- Constructor from C-string
- Copy constructor
- Assignment operator
- Destructor
- Methods: `length()`, `c_str()`, `append()`, `compare()`

**Example usage:**
```cpp
MyString str1("Hello");
MyString str2(" World");
str1.append(str2);
std::cout << str1.c_str() << std::endl; // Hello World

MyString str3 = str1; // Copy constructor
str3.append("!");
std::cout << str3.c_str() << std::endl; // Hello World!
```

**Key learning:** Introduction to the "Rule of Three" - if you need a custom destructor, you probably need custom copy constructor and assignment operator. This is fundamental to resource management in C++.

## Exercise 06: Configuration File Parser
**Turn-in directory:** `ex06/`  
**Files to turn in:** `Makefile, ConfigParser.hpp, ConfigParser.cpp, Setting.hpp, Setting.cpp, main.cpp, config.txt`  
**Forbidden functions:** None

**Concepts introduced:** File I/O with streams, string parsing, error handling

Create a configuration file parser that reads key-value pairs from a file:

**Sample config.txt:**
```
# Database Configuration
db_host=localhost
db_port=5432
db_name=myapp
max_connections=100
debug_mode=true
timeout=30.5
```

**Setting class:**
- Store a key-value pair with type information
- Support string, int, double, and bool values
- Provide type-safe getters

**ConfigParser class:**
- Load configuration from file
- Parse different data types
- Handle comments and empty lines
- Provide methods to query settings
- Handle file I/O errors gracefully

**Usage example:**
```cpp
ConfigParser config("config.txt");
if (config.load()) {
    std::string host = config.getString("db_host");
    int port = config.getInt("db_port");
    bool debug = config.getBool("debug_mode");
    double timeout = config.getDouble("timeout");
}
```

**Key learning:** Working with file streams (`std::ifstream`), string manipulation, type conversion, and error handling - all essential C++ skills that build on your C knowledge while showing C++'s advantages.

---

## Conceptual Questions for Review

After completing these exercises, consider these questions:

1. **Memory Management:** How does C++ handle memory differently from C? What are the advantages of constructors/destructors over manual `malloc()`/`free()`?

2. **Encapsulation:** Why is it better to have private data members with public getter/setter methods rather than public data members?

3. **Object Lifecycle:** In what order are constructors and destructors called for objects? How does this help with resource management?

4. **Static vs Instance:** When would you use static member variables vs instance member variables? Give practical examples.

5. **Const Correctness:** Why is it important to mark methods as `const` when they don't modify object state?

These exercises progressively build your understanding while staying true to the C++98 standard and constraints in your reference document. Each one introduces new concepts while reinforcing previous ones, preparing you for more advanced topics in later modules.
