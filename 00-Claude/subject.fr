Generated by Claude using this prompt:

I have a reference document that outlines the C++ concepts and constraints I need to learn. I have a solid foundation in C but am completely new to C++. Using this document as a guide, please generate a new, alternative series of C++ exercises designed to help me grasp the language effectively.
* The exercises should progressively introduce key C++ features (like classes, inheritance, templates,  etc.) while respecting the constraints and topics in the document.
* They should not simply repeat the examples or exercises in the attached reference but offer fresh problems and contexts.
* Each exercise should be clearly stated, with a brief explanation of the concepts it aims to teach.
* Keep in mind my C background: focus on highlighting the differences and advantages of C++ over C.
* Include a mix of practical coding tasks and conceptual questions to deepen understanding.
Please generate around 5-7 exercises for a start.

# C++ Learning Exercises - Module 00 Alternatives

## Exercise 00: Text Formatter
**Turn-in directory:** `ex00/`  
**Files to turn in:** `Makefile, formatter.cpp`  
**Forbidden functions:** `*printf()`, `*alloc()`, `free()`

**Concepts introduced:** C++ I/O streams, string manipulation, basic program structure

Write a program that takes command-line arguments and formats them according to different modes:

```bash
$> ./formatter --upper "hello world" "how are you"
HELLO WORLD HOW ARE YOU
$> ./formatter --lower "HELLO WORLD" "HOW ARE YOU"  
hello world how are you
$> ./formatter --reverse "hello" "world"
olleh dlrow
$> ./formatter --count "hello world" "test"
hello world: 11 characters
test: 4 characters
$> ./formatter
Usage: ./formatter [--upper|--lower|--reverse|--count] <text1> [text2] ...
```

**Key differences from C:** Notice how you'll use `std::cout` instead of `printf()`, `std::string` for easier string manipulation, and how C++ handles command-line arguments more elegantly.

---

## Exercise 01: Simple Calculator Class
**Turn-in directory:** `ex01/`  
**Files to turn in:** `Makefile, Calculator.hpp, Calculator.cpp, main.cpp`  
**Forbidden functions:** None

**Concepts introduced:** Classes, member functions, encapsulation, constructors

Create a `Calculator` class that maintains a running total and performs basic arithmetic operations:

```cpp
// Example usage:
Calculator calc;
calc.add(5);
calc.multiply(3);
calc.subtract(2);
std::cout << "Result: " << calc.getResult() << std::endl; // Result: 13
calc.clear();
calc.divide(10, 2);
std::cout << "Result: " << calc.getResult() << std::endl; // Result: 5
```

**Requirements:**
- The class should have private member for storing the current result
- Implement: `add()`, `subtract()`, `multiply()`, `divide()`, `clear()`, `getResult()`
- Handle division by zero appropriately
- Constructor should initialize result to 0

**Interactive mode:** Your main should allow users to enter commands like:
```
> add 5
> mul 3
> sub 2
> show
Result: 13
> quit
```

**Key learning:** This introduces you to the fundamental concept of encapsulation - data (the result) is private and can only be modified through controlled public methods.

---

## Exercise 02: Student Grade Manager
**Turn-in directory:** `ex02/`  
**Files to turn in:** `Makefile, Student.hpp, Student.cpp, GradeBook.hpp, GradeBook.cpp, main.cpp`  
**Forbidden functions:** None

**Concepts introduced:** Multiple classes, composition, member initialization lists

Create two classes:

**Student class:**
- Private members: `std::string name`, `int studentId`, `double currentGrade`
- Public methods: constructor with initialization list, getters, setters, `displayInfo()`

**GradeBook class:**
- Private members: fixed-size array of Student objects (max 50 students), current count
- Public methods: `addStudent()`, `findStudent()`, `updateGrade()`, `displayAllStudents()`, `getClassAverage()`

**Program behavior:**
```
=== Grade Management System ===
Commands: ADD, FIND, UPDATE, LIST, AVERAGE, EXIT

> ADD
Enter student name: John Doe
Enter student ID: 12345
Enter initial grade: 85.5
Student added successfully!

> LIST
ID: 12345, Name: John Doe, Grade: 85.50

> UPDATE
Enter student ID: 12345
Enter new grade: 92.0
Grade updated successfully!

> AVERAGE
Class average: 92.00
```

**Key learning:** Shows how classes can contain other classes (composition), and introduces initialization lists which are more efficient than assignment in constructors.

---

## Exercise 03: Bank Account Simulator
**Turn-in directory:** `ex03/`  
**Files to turn in:** `Makefile, BankAccount.hpp, BankAccount.cpp, Transaction.hpp, Transaction.cpp, main.cpp`  
**Forbidden functions:** None

**Concepts introduced:** Static members, const methods, more complex class design

**BankAccount class:**
- Private: `std::string accountNumber`, `std::string ownerName`, `double balance`
- Static private: `int totalAccounts`, `double totalDeposits`
- Public: constructor, `deposit()`, `withdraw()`, `getBalance() const`, `displayAccount() const`
- Static public: `getTotalAccounts()`, `getTotalDeposits()`

**Transaction class:**
- Private: `std::string type`, `double amount`, `std::string timestamp`
- Public: constructor, display method

**Features to implement:**
- Each account creation increments total account counter
- Track total money deposited across all accounts (static member)
- Withdrawal should check for sufficient funds
- `const` methods for operations that don't modify the account
- Simple transaction logging

**Sample output:**
```
Account #ACC001 - John Smith
Balance: $1,500.00
Total accounts created: 3
Total deposits made: $4,250.00
```

**Key learning:** Static members belong to the class rather than instances, `const` methods promise not to modify object state.

---

## Exercise 04: Simple String Class
**Turn-in directory:** `ex04/`  
**Files to turn in:** `Makefile, MyString.hpp, MyString.cpp, main.cpp`  
**Forbidden functions:** None

**Concepts introduced:** Dynamic memory management, copy constructor, assignment operator, destructor (Orthodox Canonical Form basics)

Create a simplified string class that manages its own memory:

**MyString class requirements:**
- Private: `char* data`, `size_t length`
- Constructor from C-string
- Copy constructor
- Assignment operator
- Destructor
- Methods: `length()`, `c_str()`, `append()`, `compare()`

**Example usage:**
```cpp
MyString str1("Hello");
MyString str2(" World");
str1.append(str2);
std::cout << str1.c_str() << std::endl; // Hello World

MyString str3 = str1; // Copy constructor
str3.append("!");
std::cout << str3.c_str() << std::endl; // Hello World!
```

**Key learning:** Introduction to the "Rule of Three" - if you need a custom destructor, you probably need custom copy constructor and assignment operator. This is fundamental to resource management in C++.

---

## Exercise 05: Employee Management System
**Turn-in directory:** `ex05/`  
**Files to turn in:** `Makefile, Employee.hpp, Employee.cpp, Department.hpp, Department.cpp, main.cpp`  
**Forbidden functions:** None

**Concepts introduced:** More complex class relationships, input validation, file-like operations

**Employee class:**
- Private: `int empId`, `std::string name`, `std::string position`, `double salary`
- Public: full Orthodox Canonical Form, getters/setters with validation

**Department class:**
- Private: `std::string deptName`, `Employee employees[100]`, `int empCount`
- Public: `addEmployee()`, `removeEmployee()`, `findEmployee()`, `calculatePayroll()`, `displayDepartment()`

**Program features:**
- Add employees with validation (salary > 0, name not empty)
- Search employees by ID or name
- Calculate total department payroll
- Display formatted employee reports
- Handle edge cases (department full, employee not found)

**Sample interaction:**
```
=== Department: Engineering ===
1. Add Employee
2. Remove Employee  
3. Find Employee
4. Show Payroll
5. List All Employees
6. Exit

Choice: 1
Enter Employee ID: 101
Enter Name: Alice Johnson
Enter Position: Software Engineer
Enter Salary: 75000
Employee added to Engineering department.

Choice: 4
Total Engineering Payroll: $225,000.00
Average Salary: $75,000.00
```

**Key learning:** Combines previous concepts while introducing validation, error handling, and more sophisticated user interaction patterns.

---

## Exercise 06: Configuration File Parser
**Turn-in directory:** `ex06/`  
**Files to turn in:** `Makefile, ConfigParser.hpp, ConfigParser.cpp, Setting.hpp, Setting.cpp, main.cpp, config.txt`  
**Forbidden functions:** None

**Concepts introduced:** File I/O with streams, string parsing, error handling

Create a configuration file parser that reads key-value pairs from a file:

**Sample config.txt:**
```
# Database Configuration
db_host=localhost
db_port=5432
db_name=myapp
max_connections=100
debug_mode=true
timeout=30.5
```

**Setting class:**
- Store a key-value pair with type information
- Support string, int, double, and bool values
- Provide type-safe getters

**ConfigParser class:**
- Load configuration from file
- Parse different data types
- Handle comments and empty lines
- Provide methods to query settings
- Handle file I/O errors gracefully

**Usage example:**
```cpp
ConfigParser config("config.txt");
if (config.load()) {
    std::string host = config.getString("db_host");
    int port = config.getInt("db_port");
    bool debug = config.getBool("debug_mode");
    double timeout = config.getDouble("timeout");
}
```

**Key learning:** Working with file streams (`std::ifstream`), string manipulation, type conversion, and error handling - all essential C++ skills that build on your C knowledge while showing C++'s advantages.

---

## Exercise 07: Matrix Calculator
**Turn-in directory:** `ex07/`  
**Files to turn in:** `Makefile, Matrix.hpp, Matrix.cpp, main.cpp`  
**Forbidden functions:** None

**Concepts introduced:** Operator overloading, more advanced memory management

Create a Matrix class that supports basic mathematical operations:

**Matrix class:**
- Private: `double** data`, `int rows`, `int cols`
- Constructor with dimensions
- Copy constructor and assignment operator (Orthodox Canonical Form)
- Destructor
- Overloaded operators: `+`, `-`, `*` (matrix multiplication), `=`, `<<` (for output)
- Methods: `transpose()`, `determinant()` (for square matrices), `display()`

**Example usage:**
```cpp
Matrix m1(2, 2);
m1.setElement(0, 0, 1); m1.setElement(0, 1, 2);
m1.setElement(1, 0, 3); m1.setElement(1, 1, 4);

Matrix m2(2, 2);
m2.setElement(0, 0, 5); m2.setElement(0, 1, 6);
m2.setElement(1, 0, 7); m2.setElement(1, 1, 8);

Matrix result = m1 + m2;
std::cout << result << std::endl;

Matrix product = m1 * m2;
std::cout << "Determinant: " << product.determinant() << std::endl;
```

**Key learning:** Operator overloading is a powerful C++ feature that allows you to define how operators work with your custom types. This exercise also reinforces proper memory management with 2D dynamic arrays.

---

## Conceptual Questions for Review

After completing these exercises, consider these questions:

1. **Memory Management:** How does C++ handle memory differently from C? What are the advantages of constructors/destructors over manual `malloc()`/`free()`?

2. **Encapsulation:** Why is it better to have private data members with public getter/setter methods rather than public data members?

3. **Object Lifecycle:** In what order are constructors and destructors called for objects? How does this help with resource management?

4. **Static vs Instance:** When would you use static member variables vs instance member variables? Give practical examples.

5. **Const Correctness:** Why is it important to mark methods as `const` when they don't modify object state?

These exercises progressively build your understanding while staying true to the C++98 standard and constraints in your reference document. Each one introduces new concepts while reinforcing previous ones, preparing you for more advanced topics in later modules.
